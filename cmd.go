package grpccmd

import (
	"crypto/ecdsa"
	"encoding/json"
	"fmt"
	"os"
	"reflect"

	"github.com/golang/protobuf/jsonpb"
	"github.com/golang/protobuf/proto"
	"github.com/sonm-io/core/util"
	"github.com/sonm-io/core/util/xgrpc"
	"github.com/spf13/cobra"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
)

var (
	rootCmd = &cobra.Command{}
	remote  = new(string)
	input   = new(string)
	ethKey  = new(ecdsa.PrivateKey)
)

func init() {
	// todo: read input as file
	rootCmd.PersistentFlags().StringVar(remote, "remote", "eth@ip", "gRPC server endpoint eth@")
	rootCmd.PersistentFlags().StringVar(input, "input", "{}", "JSON representation of the input data for the method.")
}
func SetCmdInfo(name, short string, key *ecdsa.PrivateKey) {
	rootCmd.Use = fmt.Sprintf("%s [command]", name)
	rootCmd.Short = short
	ethKey = key
}

func RegisterServiceCmd(cmd *cobra.Command) {
	rootCmd.AddCommand(cmd)
}

func Execute() error {
	return rootCmd.Execute()
}

func RunE(method, inT string, newClient func(*grpc.ClientConn) interface{}) func(*cobra.Command, []string) error {
	return func(cmd *cobra.Command, args []string) error {
		conn, err := dial()
		if err != nil {
			return err
		}
		defer conn.Close()

		c := newClient(conn)
		cv := reflect.ValueOf(c)
		method := cv.MethodByName(method)
		if method.IsValid() {
			in := reflect.New(proto.MessageType(inT).Elem()).Interface()
			if len(*input) > 0 {
				if err := json.Unmarshal([]byte(*input), in); err != nil {
					return err
				}
			}

			result := method.Call([]reflect.Value{
				reflect.ValueOf(context.Background()),
				reflect.ValueOf(in),
			})

			if len(result) != 2 {
				panic("service methods should always return 2 values")
			}

			if !result[1].IsNil() {
				return result[1].Interface().(error)
			}

			out := result[0].Interface()
			data, err := json.MarshalIndent(out, "", "  ")
			if err != nil {
				return err
			}

			cmd.Println(string(data))
		}

		return nil
	}
}

// TypeToJson takes structure type generated by protoc, instantiates structure
// and marshal structure to JSON. Used for generating requests templates.
func TypeToJson(inT string) func(cmd *cobra.Command, args []string) error {
	return func(cmd *cobra.Command, args []string) error {
		m := jsonpb.Marshaler{
			EnumsAsInts:  true,
			EmitDefaults: true,
			Indent:       "  ",
		}

		in := reflect.New(proto.MessageType(inT).Elem()).Interface().(proto.Message)
		s, err := m.MarshalToString(in)
		if err != nil {
			cmd.Printf("Cannot marshal %s to string: %s\r\n", inT, err)
			os.Exit(1)
		}

		cmd.Println(string(s))
		return nil
	}
}

// dial build ClientConn wrapper with SONM Wallet auth
func dial() (*grpc.ClientConn, error) {
	ctx := context.Background()

	_, TLSConfig, err := util.NewHitlessCertRotator(ctx, ethKey)
	if err != nil {
		return nil, err
	}

	creds := util.NewTLS(TLSConfig)
	return xgrpc.NewWalletAuthenticatedClient(ctx, creds, *remote)
}
